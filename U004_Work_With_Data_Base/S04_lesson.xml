<?xml version='1.0' encoding='UTF-8'?>
<slide xmlns="https://ulearn.me/schema/v2" title="Репозиторий" id="e9343088-72bb-4f4e-8d3c-0bfe947fc5e0">
    <markdown>
        Теперь, когда класс `Coffee` описывает допустимую, сохраняемую и извлекаемую сущность JPA,
        перейдем к соединению с базой данных.

        Настройка и установление соединения с базой данных в экосистеме Java являлось утомительной
        задачей.  Однако `Spring Data` приносит понятие репозиториев. `Repository` — описанный в `Spring
        Data` интерфейс, играющий роль удобной абстракции для различных баз данных. Существуют и
        другие механизмы доступа к базам данных из `Spring Data`, но, в большинстве случаев наиболее
        удобны различные варианты `Repository`.

        `Repository` представляет замену для следующих типов данных:

        - хранимого в базе данных объекта;
        - поля уникального идентификатора объекта/первичного ключа.

        Существует множество других видов репозиториев. Но пока нас интересуют два вида, напрямую
        связанные с примером: `CrudRepository` и JpaRepository.

        При написании кода рекомендуется использовать интерфейс самого высокого уровня из числа
        подходящих для решения задачи. `JpaRepository` расширяет несколько интерфейсов, обеспечивая
        этим более широкую функциональность, однако `CrudRepository` охватывает все ключевые
        возможности `CRUD`, этого будет достаточно для нашего пока что простого приложения.

        Определим интерфейс `CoffeeRepository` для нашего приложения, расширив интерфейс `Spring Data
        Repository` для того, чтобы наше приложение могло пользоваться репозиторием:
        ```java
            interface CoffeeRepository extends CrudRepository&lt;Coffee, String> {}
        ```
        *Два типа упомянутые тут: тип хранимого объекта и тип его уникального
        идентификатора.*

        Это простейший вариант создания репозитория в приложении Spring Boot.

        *Интересно, что Spring Boot автоматически находит драйвер базы данных (в данном случае H2)
        по пути классов, описанный в приложении интерфейс и класс JPA-сущности `Coffee` и
        самостоятельно создает прокси-компонент для базы данных.*
    </markdown>
</slide>